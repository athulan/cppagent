<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>glibmm 2.4: Gio::BufferedInputStream Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/gtkmm_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="http://www.gtkmm.org/documentation.shtml">Main Page</a> &nbsp;
  <a class="qindex" href="namespaces.html">glibmm Namespaces</a> &nbsp;
  <a href="../../../../gtkmm-2.4/docs/tutorial/html/index.html"> Book</a> &nbsp;
</center>
<hr width="100%"/>

<!-- begin main content -->
<div id="content">
<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a>
  </div>
<div class="contents">
<h1>Gio::BufferedInputStream Class Reference<br>
<small>
[<a class="el" href="group__Streams.html">Stream Classes</a>]</small>
</h1><!-- doxytag: class="Gio::BufferedInputStream" --><!-- doxytag: inherits="Gio::FilterInputStream" -->The buffered input stream implements <a class="el" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream.">FilterInputStream</a> and provides for buffered reads.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for Gio::BufferedInputStream:</div>
<div class="dynsection">
<p><center><img src="classGio_1_1BufferedInputStream__inherit__graph.png" border="0" usemap="#Gio_1_1BufferedInputStream__inherit__map" alt="Inheritance graph"></center>
<map name="Gio_1_1BufferedInputStream__inherit__map">
<area shape="rect" href="classGio_1_1DataInputStream.html" title="An implementation of BufferedInputStream that allows for high&#45;level data manipulation..." alt="" coords="16,453,163,480"><area shape="rect" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream." alt="" coords="15,304,164,330"><area shape="rect" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input." alt="" coords="29,229,149,256"><area shape="rect" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="44,154,135,181"><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="29,80,149,106"><area shape="rect" href="classsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="36,5,143,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classGio_1_1BufferedInputStream-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#6d961bb2ebe9c213c1e4c49572bae6ed">~BufferedInputStream</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GBufferedInputStream*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#a9d0c1e643650b9a45831865f06e21be">gobj</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a9d0c1e643650b9a45831865f06e21be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const GBufferedInputStream*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#d6b09565f69b4c1cf1f0ca05ee53709e">gobj</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#d6b09565f69b4c1cf1f0ca05ee53709e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GBufferedInputStream*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#47dc5f78b1faed25cdaaafe42b526d6d">gobj_copy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#47dc5f78b1faed25cdaaafe42b526d6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#46384a96dc052e9d25e1a88281d69e40">get_buffer_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the input buffer.  <a href="#46384a96dc052e9d25e1a88281d69e40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#f5f861a5b30aadc48e21fb10a46afaa7">set_buffer_size</a> (gsize size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the internal buffer of <em>stream</em> to <em>size</em>, or to the size of the contents of the buffer.  <a href="#f5f861a5b30aadc48e21fb10a46afaa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#436e3c852afdc67e8ba70d32e39ce6b9">get_available</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the available data within the stream.  <a href="#436e3c852afdc67e8ba70d32e39ce6b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#17a6489d7ab0b72268264c9f0a30e879">peek</a> (void* buffer, gsize offset, gsize count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peeks in the buffer, copying data of size <em>count</em> into <em>buffer</em>, offset <em>offset</em> bytes.  <a href="#17a6489d7ab0b72268264c9f0a30e879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const void*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#27838d9374fa86ae513bc27d939ede24">peek_buffer</a> (gsize&amp; count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns: read-only buffer.  <a href="#27838d9374fa86ae513bc27d939ede24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#197687762599fb7c5b60141b55120cde">fill</a> (gssize count, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer.  <a href="#197687762599fb7c5b60141b55120cde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#271eab4876136b4960d37350738bfdfe">fill</a> (gssize count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">non-cancellable version of <a class="el" href="classGio_1_1BufferedInputStream.html#197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a>  <a href="#271eab4876136b4960d37350738bfdfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#0a41790e04e9ba500eb18d1ce8371d34">fill_async</a> (const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, gssize count, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads data into the stream's buffer asynchronously, up to <em>count</em> size.  <a href="#0a41790e04e9ba500eb18d1ce8371d34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#adb9c1b367e36c20c91e16ea840b6ef0">fill_async</a> (const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, gssize count, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads data into the stream's buffer asynchronously, up to <em>count</em> size.  <a href="#adb9c1b367e36c20c91e16ea840b6ef0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#13c665ccc722a2544539086846137277">fill_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp; result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finishes an asynchronous read.  <a href="#13c665ccc722a2544539086846137277"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#85477f09b58dfb83e5a1ef62f119457a">read_byte</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to read a single byte from the stream or the buffer.  <a href="#85477f09b58dfb83e5a1ef62f119457a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#8741ffb62c82425f54bc5e005c2a238f">read_byte</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-cancellable version of read_byte.  <a href="#8741ffb62c82425f54bc5e005c2a238f"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br>
&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#fc33c31f5c437df14d385d3aa9d1a37b">create</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp; base_stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br>
&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#47b3b1d2c774e7c322e29beb45653bf9">create_sized</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp; base_stream, gsize size)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#0a81d8bea742203e775f796f73f46ea4">BufferedInputStream</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp; base_stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#615364466836d73513cc9c052e1d0f72">BufferedInputStream</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp; base_stream, gsize size)</td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br>
&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">Gio::BufferedInputStream</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1BufferedInputStream.html#dfe9bf4339f83095d6e96dda7b747575">wrap</a> (GBufferedInputStream* object, bool take_copy=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#dfe9bf4339f83095d6e96dda7b747575"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The buffered input stream implements <a class="el" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream.">FilterInputStream</a> and provides for buffered reads. 
<p>
By default, BufferedInputStream's buffer size is set at 4 kilobytes, but you can specify this to the constructor.<p>
To get the size of a buffer within a buffered input stream, use <a class="el" href="classGio_1_1BufferedInputStream.html#46384a96dc052e9d25e1a88281d69e40" title="Gets the size of the input buffer.">get_buffer_size()</a>. To change the size of a buffered input stream's buffer, use <a class="el" href="classGio_1_1BufferedInputStream.html#f5f861a5b30aadc48e21fb10a46afaa7" title="Sets the size of the internal buffer of stream to size, or to the size of the contents...">set_buffer_size()</a>. Note that the buffer's size cannot be reduced below the size of the data within the buffer.<p>
<dl compact><dt><b><a class="el" href="newin2p16s.html#_newin2p16s000017">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6d961bb2ebe9c213c1e4c49572bae6ed"></a><!-- doxytag: member="Gio::BufferedInputStream::~BufferedInputStream" ref="6d961bb2ebe9c213c1e4c49572bae6ed" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::BufferedInputStream::~BufferedInputStream           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0a81d8bea742203e775f796f73f46ea4"></a><!-- doxytag: member="Gio::BufferedInputStream::BufferedInputStream" ref="0a81d8bea742203e775f796f73f46ea4" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gio::BufferedInputStream::BufferedInputStream           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>base_stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="615364466836d73513cc9c052e1d0f72"></a><!-- doxytag: member="Gio::BufferedInputStream::BufferedInputStream" ref="615364466836d73513cc9c052e1d0f72" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gio::BufferedInputStream::BufferedInputStream           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>base_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a9d0c1e643650b9a45831865f06e21be"></a><!-- doxytag: member="Gio::BufferedInputStream::gobj" ref="a9d0c1e643650b9a45831865f06e21be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBufferedInputStream* Gio::BufferedInputStream::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGio_1_1FilterInputStream.html#6db43589745dcd172f4ca4082bc5d914">Gio::FilterInputStream</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#d788764326462190e900785f50a50740">Gio::DataInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="d6b09565f69b4c1cf1f0ca05ee53709e"></a><!-- doxytag: member="Gio::BufferedInputStream::gobj" ref="d6b09565f69b4c1cf1f0ca05ee53709e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GBufferedInputStream* Gio::BufferedInputStream::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGio_1_1FilterInputStream.html#c8fbd2cc879bfab4854d952b27ce271c">Gio::FilterInputStream</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#5d8f01998854eac791a3089acef051c0">Gio::DataInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="47dc5f78b1faed25cdaaafe42b526d6d"></a><!-- doxytag: member="Gio::BufferedInputStream::gobj_copy" ref="47dc5f78b1faed25cdaaafe42b526d6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBufferedInputStream* Gio::BufferedInputStream::gobj_copy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. 
<p>

<p>Reimplemented from <a class="el" href="classGio_1_1FilterInputStream.html#55ef3320e423245cc69066c90785328e">Gio::FilterInputStream</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#8252806b8ac5548c51a0418162ddb6ab">Gio::DataInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="fc33c31f5c437df14d385d3aa9d1a37b"></a><!-- doxytag: member="Gio::BufferedInputStream::create" ref="fc33c31f5c437df14d385d3aa9d1a37b" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a>&gt; Gio::BufferedInputStream::create           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>base_stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#5ecca0b3f4fdc5962c3c63e4e6706e4e">Gio::DataInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="47b3b1d2c774e7c322e29beb45653bf9"></a><!-- doxytag: member="Gio::BufferedInputStream::create_sized" ref="47b3b1d2c774e7c322e29beb45653bf9" args="(const Glib::RefPtr&lt; InputStream &gt; &amp;base_stream, gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">BufferedInputStream</a>&gt; Gio::BufferedInputStream::create_sized           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">InputStream</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>base_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="46384a96dc052e9d25e1a88281d69e40"></a><!-- doxytag: member="Gio::BufferedInputStream::get_buffer_size" ref="46384a96dc052e9d25e1a88281d69e40" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize Gio::BufferedInputStream::get_buffer_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size of the input buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current buffer size. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5f861a5b30aadc48e21fb10a46afaa7"></a><!-- doxytag: member="Gio::BufferedInputStream::set_buffer_size" ref="f5f861a5b30aadc48e21fb10a46afaa7" args="(gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::BufferedInputStream::set_buffer_size           </td>
          <td>(</td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the size of the internal buffer of <em>stream</em> to <em>size</em>, or to the size of the contents of the buffer. 
<p>
The buffer can never be resized smaller than its current contents. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>A gsize. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="436e3c852afdc67e8ba70d32e39ce6b9"></a><!-- doxytag: member="Gio::BufferedInputStream::get_available" ref="436e3c852afdc67e8ba70d32e39ce6b9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize Gio::BufferedInputStream::get_available           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size of the available data within the stream. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of the available stream. </dd></dl>

</div>
</div><p>
<a class="anchor" name="17a6489d7ab0b72268264c9f0a30e879"></a><!-- doxytag: member="Gio::BufferedInputStream::peek" ref="17a6489d7ab0b72268264c9f0a30e879" args="(void *buffer, gsize offset, gsize count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize Gio::BufferedInputStream::peek           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peeks in the buffer, copying data of size <em>count</em> into <em>buffer</em>, offset <em>offset</em> bytes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to an allocated chunk of memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>A gsize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>A gsize. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A gsize of the number of bytes peeked, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="27838d9374fa86ae513bc27d939ede24"></a><!-- doxytag: member="Gio::BufferedInputStream::peek_buffer" ref="27838d9374fa86ae513bc27d939ede24" args="(gsize &amp;count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* Gio::BufferedInputStream::peek_buffer           </td>
          <td>(</td>
          <td class="paramtype">gsize &amp;&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns: read-only buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>A gsize to get the number of bytes available in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Read-only buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="197687762599fb7c5b60141b55120cde"></a><!-- doxytag: member="Gio::BufferedInputStream::fill" ref="197687762599fb7c5b60141b55120cde" args="(gssize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::BufferedInputStream::fill           </td>
          <td>(</td>
          <td class="paramtype">gssize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to read <em>count</em> bytes from the stream into the buffer. 
<p>
Will block during this read.<p>
If <em>count</em> is zero, returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> to be thrown, with INVALID_ARGUMENT.<p>
On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.<p>
The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error.<p>
For the asynchronous, non-blocking, version of this function, see g_buffered_input_stream_fill_async(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes read into <em>stream's</em> buffer, up to <em>count</em>, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="271eab4876136b4960d37350738bfdfe"></a><!-- doxytag: member="Gio::BufferedInputStream::fill" ref="271eab4876136b4960d37350738bfdfe" args="(gssize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::BufferedInputStream::fill           </td>
          <td>(</td>
          <td class="paramtype">gssize&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
non-cancellable version of <a class="el" href="classGio_1_1BufferedInputStream.html#197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a> 
<p>

</div>
</div><p>
<a class="anchor" name="0a41790e04e9ba500eb18d1ce8371d34"></a><!-- doxytag: member="Gio::BufferedInputStream::fill_async" ref="0a41790e04e9ba500eb18d1ce8371d34" args="(const SlotAsyncReady &amp;slot, gssize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::BufferedInputStream::fill_async           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads data into the stream's buffer asynchronously, up to <em>count</em> size. 
<p>
<em>io_priority</em> can be used to prioritize reads. For the synchronous version of this function, see <a class="el" href="classGio_1_1BufferedInputStream.html#197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>the I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="adb9c1b367e36c20c91e16ea840b6ef0"></a><!-- doxytag: member="Gio::BufferedInputStream::fill_async" ref="adb9c1b367e36c20c91e16ea840b6ef0" args="(const SlotAsyncReady &amp;slot, gssize count, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::BufferedInputStream::fill_async           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads data into the stream's buffer asynchronously, up to <em>count</em> size. 
<p>
<em>io_priority</em> can be used to prioritize reads. For the synchronous version of this function, see <a class="el" href="classGio_1_1BufferedInputStream.html#197687762599fb7c5b60141b55120cde" title="Tries to read count bytes from the stream into the buffer.">fill()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>A AsyncReadyCallback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>the I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="13c665ccc722a2544539086846137277"></a><!-- doxytag: member="Gio::BufferedInputStream::fill_finish" ref="13c665ccc722a2544539086846137277" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::BufferedInputStream::fill_finish           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finishes an asynchronous read. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A gssize of the read stream, or -1 on an error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="85477f09b58dfb83e5a1ef62f119457a"></a><!-- doxytag: member="Gio::BufferedInputStream::read_byte" ref="85477f09b58dfb83e5a1ef62f119457a" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::BufferedInputStream::read_byte           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to read a single byte from the stream or the buffer. 
<p>
Will block during this read.<p>
On success, the byte read from the stream is returned. On end of stream -1 is returned but it's not an exceptional error and <em>error</em> is not set.<p>
The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The byte read from the <em>stream</em>, or -1 on end of stream or error. </dd></dl>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#ca226b5c2d1248dd079d835dd089570d">Gio::DataInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="8741ffb62c82425f54bc5e005c2a238f"></a><!-- doxytag: member="Gio::BufferedInputStream::read_byte" ref="8741ffb62c82425f54bc5e005c2a238f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::BufferedInputStream::read_byte           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-cancellable version of read_byte. 
<p>

<p>Reimplemented in <a class="el" href="classGio_1_1DataInputStream.html#f4d01aa4e791d403b79db406befcc28e">Gio::DataInputStream</a>.</p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="dfe9bf4339f83095d6e96dda7b747575"></a><!-- doxytag: member="Gio::BufferedInputStream::wrap" ref="dfe9bf4339f83095d6e96dda7b747575" args="(GBufferedInputStream *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1BufferedInputStream.html">Gio::BufferedInputStream</a>&gt; wrap           </td>
          <td>(</td>
          <td class="paramtype">GBufferedInputStream *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A <a class="el" href="namespaceGlib.html#671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&nbsp;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bufferedinputstream_8h.html">bufferedinputstream.h</a></ul>
</div>
</div> <!-- end main content -->

<hr><address><small>
Generated for glibmm 2.4 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.6 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
