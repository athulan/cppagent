<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>glibmm 2.4: Gio::InputStream Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/gtkmm_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="http://www.gtkmm.org/documentation.shtml">Main Page</a> &nbsp;
  <a class="qindex" href="namespaces.html">glibmm Namespaces</a> &nbsp;
  <a href="../../../../gtkmm-2.4/docs/tutorial/html/index.html"> Book</a> &nbsp;
</center>
<hr width="100%"/>

<!-- begin main content -->
<div id="content">
<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1InputStream.html">InputStream</a>
  </div>
<div class="contents">
<h1>Gio::InputStream Class Reference<br>
<small>
[<a class="el" href="group__Streams.html">Stream Classes</a>]</small>
</h1><!-- doxytag: class="Gio::InputStream" --><!-- doxytag: inherits="Glib::Object" -->Base class for implementing streaming input.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for Gio::InputStream:</div>
<div class="dynsection">
<p><center><img src="classGio_1_1InputStream__inherit__graph.png" border="0" usemap="#Gio_1_1InputStream__inherit__map" alt="Inheritance graph"></center>
<map name="Gio_1_1InputStream__inherit__map">
<area shape="rect" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file." alt="" coords="648,5,789,32"><area shape="rect" href="classGio_1_1FilterInputStream.html" title="Filter Input Stream." alt="" coords="644,56,793,82"><area shape="rect" href="classGio_1_1MemoryInputStream.html" title="MemoryInputStream implements InputStream for arbitrary memory chunks." alt="" coords="635,106,803,133"><area shape="rect" href="classGio_1_1UnixInputStream.html" title="UnixInputStream implements InputStream for reading from a unix file descriptor, including..." alt="" coords="645,157,792,184"><area shape="rect" href="classGlib_1_1Object.html" title="Glib::Object" alt="" coords="328,81,419,108"><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="160,81,280,108"><area shape="rect" href="classsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="5,81,112,108"><area shape="rect" href="classGio_1_1BufferedInputStream.html" title="The buffered input stream implements FilterInputStream and provides for buffered..." alt="" coords="851,56,1019,82"><area shape="rect" href="classGio_1_1DataInputStream.html" title="An implementation of BufferedInputStream that allows for high&#45;level data manipulation..." alt="" coords="1068,56,1215,82"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classGio_1_1InputStream-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#fff624e3125add13c88e8a99907ba903">~InputStream</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GInputStream*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#2ed1120b3d03a12086e7f0ed3946aba1">gobj</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#2ed1120b3d03a12086e7f0ed3946aba1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const GInputStream*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#1b0ef82ab81b3ded607584c7029fe1e9">gobj</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#1b0ef82ab81b3ded607584c7029fe1e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GInputStream*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#28a9394b07e9183c0c79798ea344c65c">gobj_copy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#28a9394b07e9183c0c79798ea344c65c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#49a1f4219f96c7fafdcf1ed12eb443e2">read</a> (void* buffer, gsize count, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#49a1f4219f96c7fafdcf1ed12eb443e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#42ab2486116d40f6ef828277befb508a">read</a> (void* buffer, gsize count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#42ab2486116d40f6ef828277befb508a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#1dc8a2babf32f93a0a5dccc0c39e0959">read_all</a> (void* buffer, gsize count, gsize&amp; bytes_read, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#1dc8a2babf32f93a0a5dccc0c39e0959"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#6da0fc57d1a5df7107370c67e84aa496">read_all</a> (void* buffer, gsize count, gsize&amp; bytes_read)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#6da0fc57d1a5df7107370c67e84aa496"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#17ea65f35c15043156db90af831a44a3">skip</a> (gsize count, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to skip <em>count</em> bytes from the stream.  <a href="#17ea65f35c15043156db90af831a44a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#1ea9146d612c666168886734b79a5d65">skip</a> (gsize count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tries to skip <em>count</em> bytes from the stream.  <a href="#1ea9146d612c666168886734b79a5d65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#1b76b2503e607475f63731a886456e09">close</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the stream, releasing resources related to it.  <a href="#1b76b2503e607475f63731a886456e09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#7a3202cf7014bcfb2c0a7f301448ae50">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes the stream, releasing resources related to it.  <a href="#7a3202cf7014bcfb2c0a7f301448ae50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#5b7762ee3f3c571fbc59a0c9af6e879e">read_async</a> (void* buffer, gsize count, const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#5b7762ee3f3c571fbc59a0c9af6e879e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#05bea76fa9ac3c098a167d2b377e36a6">read_async</a> (void* buffer, gsize count, const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#05bea76fa9ac3c098a167d2b377e36a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#c089ab220e671ba0af2dd97f2405c0c5">read_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp; result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finishes an asynchronous stream read operation.  <a href="#c089ab220e671ba0af2dd97f2405c0c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#1bf7a4a30005813b0a46e069215907a2">skip_async</a> (gsize count, const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#1bf7a4a30005813b0a46e069215907a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#111e86dad4548394edcff16d7735d2d5">skip_async</a> (gsize count, const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>.  <a href="#111e86dad4548394edcff16d7735d2d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gssize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#1522468bd203ab3082ab54e9eba68b03">skip_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp; result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finishes a stream skip operation.  <a href="#1522468bd203ab3082ab54e9eba68b03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#f66159778ee2d577e9df52063ced53bf">close_async</a> (const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp; cancellable, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests an asynchronous closes of the stream, releasing resources related to it.  <a href="#f66159778ee2d577e9df52063ced53bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#b5160982124f34ed6e475776acd126d2">close_async</a> (const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=Glib::PRIORITY_DEFAULT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Requests an asynchronous closes of the stream, releasing resources related to it.  <a href="#b5160982124f34ed6e475776acd126d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#e5a0d2c3ccf27661e374f151117a8fb7">close_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp; result)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finishes closing a stream asynchronously, started from g_input_stream_close_async().  <a href="#e5a0d2c3ccf27661e374f151117a8fb7"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">Gio::InputStream</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1InputStream.html#ec580b0fc1e0807d7ccba6cbb7e302db">wrap</a> (GInputStream* object, bool take_copy=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#ec580b0fc1e0807d7ccba6cbb7e302db"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for implementing streaming input. 
<p>
<dl compact><dt><b><a class="el" href="newin2p16s.html#_newin2p16s000037">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="fff624e3125add13c88e8a99907ba903"></a><!-- doxytag: member="Gio::InputStream::~InputStream" ref="fff624e3125add13c88e8a99907ba903" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::InputStream::~InputStream           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2ed1120b3d03a12086e7f0ed3946aba1"></a><!-- doxytag: member="Gio::InputStream::gobj" ref="2ed1120b3d03a12086e7f0ed3946aba1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GInputStream* Gio::InputStream::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#4c6efc18be8cb9c56e58fc0bd20fafbe">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#a9d0c1e643650b9a45831865f06e21be">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#d788764326462190e900785f50a50740">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#5411e06810e06ad339d7a21257772219">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#6db43589745dcd172f4ca4082bc5d914">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#076380153e01599446bd991e0985db69">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#a0b863b654d38a9e10f7d7d49b82c5ea">Gio::UnixInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="1b0ef82ab81b3ded607584c7029fe1e9"></a><!-- doxytag: member="Gio::InputStream::gobj" ref="1b0ef82ab81b3ded607584c7029fe1e9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GInputStream* Gio::InputStream::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGlib_1_1ObjectBase.html#778a94181132976bbfb0519793f3b32e">Glib::ObjectBase</a>.</p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#d6b09565f69b4c1cf1f0ca05ee53709e">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#5d8f01998854eac791a3089acef051c0">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#b1afea7b758100ca02a6aa5b89d57662">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#c8fbd2cc879bfab4854d952b27ce271c">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#f9ea44af840fc0d29d460498c8ce7d0e">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#dc7b87c43606f90378a521df99220971">Gio::UnixInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="28a9394b07e9183c0c79798ea344c65c"></a><!-- doxytag: member="Gio::InputStream::gobj_copy" ref="28a9394b07e9183c0c79798ea344c65c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GInputStream* Gio::InputStream::gobj_copy           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. 
<p>

<p>Reimplemented in <a class="el" href="classGio_1_1BufferedInputStream.html#47dc5f78b1faed25cdaaafe42b526d6d">Gio::BufferedInputStream</a>, <a class="el" href="classGio_1_1DataInputStream.html#8252806b8ac5548c51a0418162ddb6ab">Gio::DataInputStream</a>, <a class="el" href="classGio_1_1FileInputStream.html#a35ad981b6f18b1e5ece395970c5991b">Gio::FileInputStream</a>, <a class="el" href="classGio_1_1FilterInputStream.html#55ef3320e423245cc69066c90785328e">Gio::FilterInputStream</a>, <a class="el" href="classGio_1_1MemoryInputStream.html#f63cbdce2036e383cb7e77a7df83651c">Gio::MemoryInputStream</a>, and <a class="el" href="classGio_1_1UnixInputStream.html#5f05de3f98b2dd8e7f0f2c5038fbc69f">Gio::UnixInputStream</a>.</p>

</div>
</div><p>
<a class="anchor" name="49a1f4219f96c7fafdcf1ed12eb443e2"></a><!-- doxytag: member="Gio::InputStream::read" ref="49a1f4219f96c7fafdcf1ed12eb443e2" args="(void *buffer, gsize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::read           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
Will block during this read.<p>
If count is zero returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.<p>
On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.<p>
The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes read, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="42ab2486116d40f6ef828277befb508a"></a><!-- doxytag: member="Gio::InputStream::read" ref="42ab2486116d40f6ef828277befb508a" args="(void *buffer, gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::read           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
Will block during this read.<p>
If count is zero returns zero and does nothing. A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.<p>
On success, the number of bytes read into the buffer is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.<p>
On error -1 is returned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be read from the stream. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes read, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1dc8a2babf32f93a0a5dccc0c39e0959"></a><!-- doxytag: member="Gio::InputStream::read_all" ref="1dc8a2babf32f93a0a5dccc0c39e0959" args="(void *buffer, gsize count, gsize &amp;bytes_read, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::read_all           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
Will block during this read.<p>
This function is similar to g_input_stream_read(), except it tries to read as many bytes as requested, only stopping on an error or end of stream.<p>
On a successful read of <em>count</em> bytes, or if we reached the end of the stream, <code>true</code> is returned, and <em>bytes_read</em> is set to the number of bytes read into <em>buffer</em>.<p>
If there is an error during the operation <code>false</code> is returned and <em>error</em> is set to indicate the error status, <em>bytes_read</em> is updated to contain the number of bytes read into <em>buffer</em> before the error occurred. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>Location to store the number of bytes that was read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object, <code>0</code> to ignore. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> if there was an error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6da0fc57d1a5df7107370c67e84aa496"></a><!-- doxytag: member="Gio::InputStream::read_all" ref="6da0fc57d1a5df7107370c67e84aa496" args="(void *buffer, gsize count, gsize &amp;bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::read_all           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to read <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
Will block during this read.<p>
This function is similar to <a class="el" href="classGio_1_1InputStream.html#49a1f4219f96c7fafdcf1ed12eb443e2" title="Tries to read count bytes from the stream into the buffer starting at buffer.">read()</a>, except it tries to read as many bytes as requested, only stopping on an error or end of stream.<p>
On a successful read of <em>count</em> bytes, or if we reached the end of the stream, <code>true</code> is returned, and <em>bytes_read</em> is set to the number of bytes read into <em>buffer</em> .<p>
If there is an error during the operation <code>false</code> is returned and a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> is thrown to indicate the error status, <em>bytes_read</em> is updated to contain the number of bytes read into <em>buffer</em> before the error occured. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>Location to store the number of bytes that was read from the stream. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> if there was an error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="17ea65f35c15043156db90af831a44a3"></a><!-- doxytag: member="Gio::InputStream::skip" ref="17ea65f35c15043156db90af831a44a3" args="(gsize count, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::skip           </td>
          <td>(</td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to skip <em>count</em> bytes from the stream. 
<p>
Will block during the operation.<p>
This is identical to g_input_stream_read(), from a behaviour standpoint, but the bytes that are skipped are not returned to the user. Some streams have an implementation that is more efficient than reading the data.<p>
This function is optional for inherited classes, as the default implementation emulates it using read.<p>
The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes skipped, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ea9146d612c666168886734b79a5d65"></a><!-- doxytag: member="Gio::InputStream::skip" ref="1ea9146d612c666168886734b79a5d65" args="(gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::skip           </td>
          <td>(</td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tries to skip <em>count</em> bytes from the stream. 
<p>
Will block during the operation.<p>
This is identical to <a class="el" href="classGio_1_1InputStream.html#49a1f4219f96c7fafdcf1ed12eb443e2" title="Tries to read count bytes from the stream into the buffer starting at buffer.">read()</a>, from a behaviour standpoint, but the bytes that are skipped are not returned to the user. Some streams have an implementation that is more efficient than reading the data.<p>
This function is optional for inherited classes, as the default implementation emulates it using read.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes skipped, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b76b2503e607475f63731a886456e09"></a><!-- doxytag: member="Gio::InputStream::close" ref="1b76b2503e607475f63731a886456e09" args="(const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::close           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes the stream, releasing resources related to it. 
<p>
Once the stream is closed, all other operations will throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED. Closing a stream multiple times will not return an error.<p>
Streams will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.<p>
Some streams might keep the backing store of the stream (e.g. a file descriptor) open after the stream is closed. See the documentation for the individual stream for details.<p>
On failure the first error that happened will be reported, but the close operation will finish as much as possible. A stream that failed to close will still throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED for all operations. Still, it is important to check and report the error to the user.<p>
The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> will be thrown with CANCELLED. Cancelling a close will still leave the stream closed, but some streams can use a faster close that doesn't block to e.g. check errors. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a3202cf7014bcfb2c0a7f301448ae50"></a><!-- doxytag: member="Gio::InputStream::close" ref="7a3202cf7014bcfb2c0a7f301448ae50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::InputStream::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes the stream, releasing resources related to it. 
<p>
Once the stream is closed, all other operations will throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED. Closing a stream multiple times will not return an error.<p>
Streams will be automatically closed when the last reference is dropped, but you might want to call this make sure resources are released as early as possible.<p>
Some streams might keep the backing store of the stream (e.g. a file descriptor) open after the stream is closed. See the documentation for the individual stream for details.<p>
On failure the first error that happened will be reported, but the close operation will finish as much as possible. A stream that failed to close will still throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with CLOSED for all operations. Still, it is important to check and report the error to the user.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> on success, <code>false</code> on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5b7762ee3f3c571fbc59a0c9af6e879e"></a><!-- doxytag: member="Gio::InputStream::read_async" ref="5b7762ee3f3c571fbc59a0c9af6e879e" args="(void *buffer, gsize count, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::read_async           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#c089ab220e671ba0af2dd97f2405c0c5" title="Finishes an asynchronous stream read operation.">read_finish()</a> to get the result of the operation.<p>
During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.<p>
A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.<p>
On success, the number of bytes read into the buffer will be passed to the <em>slot</em> callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to read as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.<p>
Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.<p>
The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>The I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="05bea76fa9ac3c098a167d2b377e36a6"></a><!-- doxytag: member="Gio::InputStream::read_async" ref="05bea76fa9ac3c098a167d2b377e36a6" args="(void *buffer, gsize count, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::read_async           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request an asynchronous read of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#c089ab220e671ba0af2dd97f2405c0c5" title="Finishes an asynchronous stream read operation.">read_finish()</a> to get the result of the operation.<p>
During an async request no other sync and async calls are allowed, and will result in a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.<p>
A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.<p>
On success, the number of bytes read into the buffer will be passed to the <em>slot</em> callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to read as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.<p>
Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.<p>
The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A buffer to read data into (which should be at least count bytes long). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be read from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>The I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c089ab220e671ba0af2dd97f2405c0c5"></a><!-- doxytag: member="Gio::InputStream::read_finish" ref="c089ab220e671ba0af2dd97f2405c0c5" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::read_finish           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finishes an asynchronous stream read operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of bytes read in, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1bf7a4a30005813b0a46e069215907a2"></a><!-- doxytag: member="Gio::InputStream::skip_async" ref="1bf7a4a30005813b0a46e069215907a2" args="(gsize count, const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::skip_async           </td>
          <td>(</td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#1522468bd203ab3082ab54e9eba68b03" title="Finishes a stream skip operation.">skip_finish()</a> to get the result of the operation.<p>
During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.<p>
A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.<p>
On success, the number of bytes skipped will be passed to the callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to skip as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.<p>
Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.<p>
The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>The I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="111e86dad4548394edcff16d7735d2d5"></a><!-- doxytag: member="Gio::InputStream::skip_async" ref="111e86dad4548394edcff16d7735d2d5" args="(gsize count, const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::skip_async           </td>
          <td>(</td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Request an asynchronous skip of <em>count</em> bytes from the stream into the buffer starting at <em>buffer</em>. 
<p>
When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#1522468bd203ab3082ab54e9eba68b03" title="Finishes a stream skip operation.">skip_finish()</a> to get the result of the operation.<p>
During an async request no other sync and async calls are allowed, and will result in <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with PENDING being thrown.<p>
A value of <em>count</em> larger than MAXSSIZE will cause a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors.">Gio::Error</a> with INVALID_ARGUMENT to be thrown.<p>
On success, the number of bytes skipped will be passed to the callback. It is not an error if this is not the same as the requested size, as it can happen e.g. near the end of a file, but generally we try to skip as many bytes as requested. Zero is returned on end of file (or if <em>count</em> is zero), but never otherwise.<p>
Any outstanding i/o request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is PRIORITY_DEFAULT.<p>
The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes that will be skipped from the stream. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>The I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1522468bd203ab3082ab54e9eba68b03"></a><!-- doxytag: member="Gio::InputStream::skip_finish" ref="1522468bd203ab3082ab54e9eba68b03" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::InputStream::skip_finish           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finishes a stream skip operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The size of the bytes skipped, or -1 on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f66159778ee2d577e9df52063ced53bf"></a><!-- doxytag: member="Gio::InputStream::close_async" ref="f66159778ee2d577e9df52063ced53bf" args="(const SlotAsyncReady &amp;slot, const Glib::RefPtr&lt; Cancellable &gt; &amp;cancellable, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::close_async           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Requests an asynchronous closes of the stream, releasing resources related to it. 
<p>
When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#e5a0d2c3ccf27661e374f151117a8fb7" title="Finishes closing a stream asynchronously, started from g_input_stream_close_async()...">close_finish()</a> to get the result of the operation.<p>
For behaviour details see <a class="el" href="classGio_1_1InputStream.html#7a3202cf7014bcfb2c0a7f301448ae50" title="Closes the stream, releasing resources related to it.">close()</a>.<p>
The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cancellable</em>&nbsp;</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>The I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b5160982124f34ed6e475776acd126d2"></a><!-- doxytag: member="Gio::InputStream::close_async" ref="b5160982124f34ed6e475776acd126d2" args="(const SlotAsyncReady &amp;slot, int io_priority=Glib::PRIORITY_DEFAULT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::InputStream::close_async           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>io_priority</em> = <code>Glib::PRIORITY_DEFAULT</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Requests an asynchronous closes of the stream, releasing resources related to it. 
<p>
When the operation is finished <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1InputStream.html#e5a0d2c3ccf27661e374f151117a8fb7" title="Finishes closing a stream asynchronously, started from g_input_stream_close_async()...">close_finish()</a> to get the result of the operation.<p>
For behaviour details see <a class="el" href="classGio_1_1InputStream.html#7a3202cf7014bcfb2c0a7f301448ae50" title="Closes the stream, releasing resources related to it.">close()</a>.<p>
The asyncronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>Callback to call when the request is satisfied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_priority</em>&nbsp;</td><td>The I/O priority of the request. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5a0d2c3ccf27661e374f151117a8fb7"></a><!-- doxytag: member="Gio::InputStream::close_finish" ref="e5a0d2c3ccf27661e374f151117a8fb7" args="(const Glib::RefPtr&lt; AsyncResult &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean Gio::InputStream::close_finish           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>&gt;&amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finishes closing a stream asynchronously, started from g_input_stream_close_async(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if the stream was closed successfully. </dd></dl>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="ec580b0fc1e0807d7ccba6cbb7e302db"></a><!-- doxytag: member="Gio::InputStream::wrap" ref="ec580b0fc1e0807d7ccba6cbb7e302db" args="(GInputStream *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1InputStream.html">Gio::InputStream</a>&gt; wrap           </td>
          <td>(</td>
          <td class="paramtype">GInputStream *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A <a class="el" href="namespaceGlib.html#671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&nbsp;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="inputstream_8h.html">inputstream.h</a></ul>
</div>
</div> <!-- end main content -->

<hr><address><small>
Generated for glibmm 2.4 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.6 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
