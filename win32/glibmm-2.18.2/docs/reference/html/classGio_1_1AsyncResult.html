<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>glibmm 2.4: Gio::AsyncResult Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/gtkmm_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="http://www.gtkmm.org/documentation.shtml">Main Page</a> &nbsp;
  <a class="qindex" href="namespaces.html">glibmm Namespaces</a> &nbsp;
  <a href="../../../../gtkmm-2.4/docs/tutorial/html/index.html"> Book</a> &nbsp;
</center>
<hr width="100%"/>

<!-- begin main content -->
<div id="content">
<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespaceGio.html">Gio</a>::<a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a>
  </div>
<div class="contents">
<h1>Gio::AsyncResult Class Reference</h1><!-- doxytag: class="Gio::AsyncResult" --><!-- doxytag: inherits="Glib::Interface" -->Provides a base class for implementing asynchronous function results.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for Gio::AsyncResult:</div>
<div class="dynsection">
<p><center><img src="classGio_1_1AsyncResult__inherit__graph.png" border="0" usemap="#Gio_1_1AsyncResult__inherit__map" alt="Inheritance graph"></center>
<map name="Gio_1_1AsyncResult__inherit__map">
<area shape="rect" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="15,154,119,181"><area shape="rect" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces." alt="" coords="7,80,127,106"><area shape="rect" href="classsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="13,5,120,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classGio_1_1AsyncResult-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#9dae859748e44341d2c14a2777ca4fee">~AsyncResult</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GAsyncResult*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#d7ebc2ac808bd8eff4f4cd4f94c1c70a">gobj</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#d7ebc2ac808bd8eff4f4cd4f94c1c70a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const GAsyncResult*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#134862761e05a548d2817505480140be">gobj</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#134862761e05a548d2817505480140be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#3b89bee3ed3ff402ff58f836e1d2398e">get_source_object</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>.  <a href="#3b89bee3ed3ff402ff58f836e1d2398e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#dcb9d80c42cf04098629a8153d51b32c">get_source_object</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>.  <a href="#dcb9d80c42cf04098629a8153d51b32c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br>
&lt;<a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#97f3fe7208156d2c981f42e97ec4ce20">get_source_object_vfunc</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#27a2e7a0488f8a3db08fa9547c791c6a">add_interface</a> (GType gtype_implementer)</td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">Gio::AsyncResult</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1AsyncResult.html#08e7667c305f6c361345c9a8e261d73a">wrap</a> (GAsyncResult* object, bool take_copy=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#08e7667c305f6c361345c9a8e261d73a"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Provides a base class for implementing asynchronous function results. 
<p>
Asynchronous operations are broken up into two separate operations which are chained together by a SlotAsyncReady. To begin an asynchronous operation, provide a SlotAsyncReady to the asynchronous function. This callback will be triggered when the operation has completed, and will be passed an <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> instance filled with the details of the operation's success or failure, the object the asynchronous function was started for and any error codes returned. The asynchronous callback function is then expected to call the corresponding "_finish()" function with the object the function was called for, and the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> instance.<p>
The purpose of the "_finish()" function is to take the generic result of type <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> and return the specific result that the operation in question yields (e.g. a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines.">FileEnumerator</a> for an "enumerate children" operation). If the result or error status of the operation is not needed, there is no need to call the "_finish()" function and GIO will take care of cleaning up the result and error information after the SlotAsyncReady returns. You may also store the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a> and call "_finish()" later.<p>
Example of a typical asynchronous operation flow: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> _theoretical_frobnitz_async(<span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Theoretical&gt;</a>&amp; t, 
                                  <span class="keyword">const</span> <a class="code" href="namespaceGio.html#ecaa02709f9ab83fa2b36d2571665cbe" title="A function that will be called when an asynchronous operation within GIO has been...">SlotAsyncReady</a>&amp; slot);
 
 gboolean _theoretical_frobnitz_finish(<span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Theoretical&gt;</a>&amp; t,
                                       <span class="keyword">const</span> <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;AsyncResult&gt;</a>&amp; result);
 
 <span class="keyword">static</span> <span class="keywordtype">void</span> 
 on_frobnitz_result(<a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;AsyncResult&gt;</a>&amp; result)
 {
 
   <a class="code" href="classGlib_1_1RefPtr.html" title="RefPtr&amp;lt;&amp;gt; is a reference-counting shared smartpointer.">Glib::RefPtr&lt;Glib::Object&gt;</a> source_object = result-&gt;get_source_object();
   <span class="keywordtype">bool</span> success = _theoretical_frobnitz_finish(source_object, res);
 
   <span class="keywordflow">if</span> (success)
     <a class="codeRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a81">std::cout</a> &lt;&lt; <span class="stringliteral">"Hurray"</span> &lt;&lt; <a class="codeRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a688">std::endl</a>;
   <span class="keywordflow">else</span> 
     <a class="codeRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a81">std::cout</a> &lt;&lt; <span class="stringliteral">"Uh oh!"</span> &lt;&lt; std::endl;
 
   ...
 }
 
 <span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">void</span> *argv[])
 {
    ...
 
    _theoretical_frobnitz_async (theoretical_data, 
                                 <a class="codeRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/group__s20__3__7__adaptors.html#ga1">sigc::ptr_fun</a>(&amp;on_frobnitz_result) );
 
    ...
 }
</pre></div><p>
The async function could also take an optional Glib::Cancellable object, allowing the calling function to cancel the asynchronous operation.<p>
The callback for an asynchronous operation is called only once, and is always called, even in the case of a cancelled operation. On cancellation the result is a ERROR_CANCELLED error.<p>
Some ascynchronous operations are implemented using synchronous calls. These are run in a separate GThread, but otherwise they are sent to the Main Event Loop and processed in an idle function. So, if you truly need asynchronous operations, make sure to initialize GThread.<p>
<dl compact><dt><b><a class="el" href="newin2p16s.html#_newin2p16s000016">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9dae859748e44341d2c14a2777ca4fee"></a><!-- doxytag: member="Gio::AsyncResult::~AsyncResult" ref="9dae859748e44341d2c14a2777ca4fee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::AsyncResult::~AsyncResult           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="27a2e7a0488f8a3db08fa9547c791c6a"></a><!-- doxytag: member="Gio::AsyncResult::add_interface" ref="27a2e7a0488f8a3db08fa9547c791c6a" args="(GType gtype_implementer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Gio::AsyncResult::add_interface           </td>
          <td>(</td>
          <td class="paramtype">GType&nbsp;</td>
          <td class="paramname"> <em>gtype_implementer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d7ebc2ac808bd8eff4f4cd4f94c1c70a"></a><!-- doxytag: member="Gio::AsyncResult::gobj" ref="d7ebc2ac808bd8eff4f4cd4f94c1c70a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GAsyncResult* Gio::AsyncResult::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#969e9396f75132a9577428f4fa932d42">Glib::Interface</a>.</p>

</div>
</div><p>
<a class="anchor" name="134862761e05a548d2817505480140be"></a><!-- doxytag: member="Gio::AsyncResult::gobj" ref="134862761e05a548d2817505480140be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GAsyncResult* Gio::AsyncResult::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides access to the underlying C GObject. 
<p>

<p>Reimplemented from <a class="el" href="classGlib_1_1Interface.html#70a443071a69d3372c2cdd7128a91ed1">Glib::Interface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3b89bee3ed3ff402ff58f836e1d2398e"></a><!-- doxytag: member="Gio::AsyncResult::get_source_object" ref="3b89bee3ed3ff402ff58f836e1d2398e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt; Gio::AsyncResult::get_source_object           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The source object for the <em>res</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dcb9d80c42cf04098629a8153d51b32c"></a><!-- doxytag: member="Gio::AsyncResult::get_source_object" ref="dcb9d80c42cf04098629a8153d51b32c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt; Gio::AsyncResult::get_source_object           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the source object from a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results.">AsyncResult</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The source object for the <em>res</em>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="97f3fe7208156d2c981f42e97ec4ce20"></a><!-- doxytag: member="Gio::AsyncResult::get_source_object_vfunc" ref="97f3fe7208156d2c981f42e97ec4ce20" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Object.html">Glib::Object</a>&gt; Gio::AsyncResult::get_source_object_vfunc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="08e7667c305f6c361345c9a8e261d73a"></a><!-- doxytag: member="Gio::AsyncResult::wrap" ref="08e7667c305f6c361345c9a8e261d73a" args="(GAsyncResult *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AsyncResult.html">Gio::AsyncResult</a>&gt; wrap           </td>
          <td>(</td>
          <td class="paramtype">GAsyncResult *&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>take_copy</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A <a class="el" href="namespaceGlib.html#671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>object</em>&nbsp;</td><td>The C instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>take_copy</em>&nbsp;</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="asyncresult_8h.html">asyncresult.h</a></ul>
</div>
</div> <!-- end main content -->

<hr><address><small>
Generated for glibmm 2.4 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.6 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
