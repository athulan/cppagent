<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>glibmm 2.4: Glib::IOChannel Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<table border="0" width="100%">
<tr>
    <td width="10%" height="40"><img src="../../images/gtkmm_logo.gif" alt="logo" border="0" width="100%" height="100%"/></td>
    <td width="90%" height="40"><img src="../../images/top.gif" alt="top" width="100%" height="40"/></td>
</tr>
</table>
<center>
  <a class="qindex" href="http://www.gtkmm.org/documentation.shtml">Main Page</a> &nbsp;
  <a class="qindex" href="namespaces.html">glibmm Namespaces</a> &nbsp;
  <a href="../../../../gtkmm-2.4/docs/tutorial/html/index.html"> Book</a> &nbsp;
</center>
<hr width="100%"/>

<!-- begin main content -->
<div id="content">
<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespaceGlib.html">Glib</a>::<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>
  </div>
<div class="contents">
<h1>Glib::IOChannel Class Reference</h1><!-- doxytag: class="Glib::IOChannel" --><!-- doxytag: inherits="sigc::trackable" --><a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> aims to provide portable I/O support for files, pipes and sockets, and to integrate them with the GLib main event loop.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for Glib::IOChannel:</div>
<div class="dynsection">
<p><center><img src="classGlib_1_1IOChannel__inherit__graph.png" border="0" usemap="#Glib_1_1IOChannel__inherit__map" alt="Inheritance graph"></center>
<map name="Glib_1_1IOChannel__inherit__map">
<area shape="rect" href="classGlib_1_1StreamIOChannel.html" title="This whole class is deprecated in glibmm&nbsp;2.2." alt="" coords="5,155,160,182"><area shape="rect" href="classsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="29,6,136,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classGlib_1_1IOChannel-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#0a6c1cddcf00c77c6ab99b096c86544f">~IOChannel</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#e5878a4510f52f194f18c0743f6a9b5c">read</a> (gunichar&amp; thechar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a single UCS-4 character.  <a href="#e5878a4510f52f194f18c0743f6a9b5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#1afb78d2e29a2f01a7034279a0c12636">read</a> (char* buf, gsize count, gsize&amp; bytes_read)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a character sequence into memory.  <a href="#1afb78d2e29a2f01a7034279a0c12636"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#4553088deea02ebea2ab7a9e2cff0a1c">read</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str, gsize count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a maximum of <em>count</em> bytes into <em>str</em>.  <a href="#4553088deea02ebea2ab7a9e2cff0a1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#2950510fff168d5753ee1eb14714d67a">read_line</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; line)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a whole line.  <a href="#2950510fff168d5753ee1eb14714d67a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#0d64e84ab360b3c83399c94076487df1">read_to_end</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads all the remaining data from the file.  <a href="#0d64e84ab360b3c83399c94076487df1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#cacb5599be21f549911c6aca5f820fcf">write</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a string to the I/O channel.  <a href="#cacb5599be21f549911c6aca5f820fcf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#29114ed2bcb64b8af551271394968528">write</a> (const char* buf, gssize count, gsize&amp; bytes_written)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a memory area of <em>count</em> bytes to the I/O channel.  <a href="#29114ed2bcb64b8af551271394968528"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#5e0a187ff012b3b90c6d3d8593c18e92">write</a> (gunichar unichar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a single UCS-4 character to the I/O channel.  <a href="#5e0a187ff012b3b90c6d3d8593c18e92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#65a5048c32ecde11827b5ae1973ee0b1">seek</a> (gint64 offset, <a class="el" href="group__glibmmEnums.html#ga3767731311bdba4ef42dc99215e5cda">SeekType</a> type=SEEK_TYPE_SET)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek the I/O channel to a specific position.  <a href="#65a5048c32ecde11827b5ae1973ee0b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ba6702093bd1c58ea22231446ed2f6e4">flush</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the buffers of the I/O channel.  <a href="#ba6702093bd1c58ea22231446ed2f6e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#6affd4b4cbeeefe4965544f762922c35">close</a> (bool flush=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the I/O channel.  <a href="#6affd4b4cbeeefe4965544f762922c35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">gsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#2f5c5979ad729df9524fcb1940e5d2fe">get_buffer_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> internal buffer size.  <a href="#2f5c5979ad729df9524fcb1940e5d2fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#535767c92f2678e5e72051f6f4bc5326">set_buffer_size</a> (gsize size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the internal <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> buffer size.  <a href="#535767c92f2678e5e72051f6f4bc5326"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#c15e424b863d398ed458315b7f799243">get_flags</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current flags for a <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a>, including read-only flags such as <a class="el" href="group__glibmmEnums.html#ggee093e5db5bc1ea5738771ba0d1af3b7162bfe5ccb18465d0f11e954cc4a89d9">Glib::IO_FLAG_IS_READABLE</a>.  <a href="#c15e424b863d398ed458315b7f799243"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#b6c16c87c174d836247f47c2b87539fd">set_flags</a> (<a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set flags on the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a>.  <a href="#b6c16c87c174d836247f47c2b87539fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#baf37b0d76cd41628fd0c41a674495de">set_buffered</a> (bool buffered)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the buffering status of the I/O channel.  <a href="#baf37b0d76cd41628fd0c41a674495de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#3013c245f30ca81e11c01f8a031b1745">get_buffered</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the buffering status of the I/O channel.  <a href="#3013c245f30ca81e11c01f8a031b1745"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__MainLoop.html#gbd96381793b70d4ae32c725926990918">IOCondition</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#9ba943e998468e3b86d841c5aec8a551">get_buffer_condition</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the I/O channel.  <a href="#9ba943e998468e3b86d841c5aec8a551"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#c93b128c8ee396702b2a20c5a060949d">get_close_on_unref</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the file/socket/whatever associated with the I/O channel will be closed when the channel receives its final unref and is destroyed.  <a href="#c93b128c8ee396702b2a20c5a060949d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#3f4fbc2a4c3670863fbf504d7fc96253">set_close_on_unref</a> (bool do_close)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setting this flag to <code>true</code> for a channel you have already closed can cause problems.  <a href="#3f4fbc2a4c3670863fbf504d7fc96253"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#b1d3ae667bd425ef830929a67cf526e0">set_encoding</a> (const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>&amp; encoding=<a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the encoding for the input/output of the channel.  <a href="#b1d3ae667bd425ef830929a67cf526e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#e52a79ec5f3acc2b0990870668c4ea2a">get_encoding</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the encoding of the I/O channel.  <a href="#e52a79ec5f3acc2b0990870668c4ea2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#d42d03bdd0288cf5517737a73f7268b3">set_line_term</a> (const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>&amp; term=<a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#fd08e7a2a6cbfbdad2ef599c9eadcc01">get_line_term</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOSource.html">IOSource</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#755c88fe8c78dc0727b5686fc62b736c">create_watch</a> (<a class="el" href="group__MainLoop.html#gbd96381793b70d4ae32c725926990918">IOCondition</a> condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object.  <a href="#755c88fe8c78dc0727b5686fc62b736c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a63e3a39347848387cd9422d0073a7be">reference</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#4c57bf6b00844fc3ddb9d0e60cac7dcf">unreference</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">GIOChannel*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#b05ed8535a51b04749e11386c845a581">gobj</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const GIOChannel*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ad550f12d9d2ec2fef0a2c7ba78f2595">gobj</a> () const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#c175ea1fd6ef84ac3758ca57b42b7f33">create_from_file</a> (const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>&amp; filename, const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>&amp; mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a file <em>filename</em> as an I/O channel using mode <em>mode</em>.  <a href="#c175ea1fd6ef84ac3758ca57b42b7f33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#078698e18f61bb75fe3fd33d82970f5d">create_from_fd</a> (int fd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an I/O channel from a file descriptor.  <a href="#078698e18f61bb75fe3fd33d82970f5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#1a22bd01752d233c23babdef800c0d87">create_from_win32_fd</a> (int fd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an I/O channel for C runtime (emulated Unix-like) file descriptors.  <a href="#1a22bd01752d233c23babdef800c0d87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#087946554b86d42f1cd72277fd1b0530">create_from_win32_socket</a> (int socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an I/O channel for a winsock socket.  <a href="#087946554b86d42f1cd72277fd1b0530"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ded3d9a998914bcac0b3f1aef1eeb974">IOChannel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor that should be used by derived classes.  <a href="#ded3d9a998914bcac0b3f1aef1eeb974"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#bfb4faa07e80b86f21b0f18f0b8606cd">read_vfunc</a> (char* buf, gsize count, gsize&amp; bytes_read)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#4ed5372da9d4ad3465012fc2317507b5">write_vfunc</a> (const char* buf, gsize count, gsize&amp; bytes_written)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#781de88aec2c032d05f74402779665f3">seek_vfunc</a> (gint64 offset, <a class="el" href="group__glibmmEnums.html#ga3767731311bdba4ef42dc99215e5cda">SeekType</a> type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#735b70808acbb542b04bf55b0133927e">close_vfunc</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#f8f690f1e0a8945b75ad7be4949e44cf">set_flags_vfunc</a> (<a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#e3326db3877358b563de11fb3dd8367f">get_flags_vfunc</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a><br>
&lt;<a class="el" href="classGlib_1_1Source.html">Glib::Source</a>&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#128f2bfd977617a6a1a7e4a7fbe6aa5b">create_watch_vfunc</a> (<a class="el" href="group__MainLoop.html#gbd96381793b70d4ae32c725926990918">IOCondition</a> cond)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GIOChannel*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#6683e47c0d78492b83d7021288d9b6d0">gobject_</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> aims to provide portable I/O support for files, pipes and sockets, and to integrate them with the GLib main event loop. 
<p>
Note that IOChannels implement an automatic implicit character set conversion to the data stream, and usually will not pass by default binary data unchanged. To set the encoding of the channel, use e.g. set_encoding("ISO-8859-15"). To set the channel to no encoding, use <a class="el" href="classGlib_1_1IOChannel.html#b1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel.">set_encoding()</a> without any arguments.<p>
You can create an <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> with one of the static create methods, or implement one yourself, in which case you have to 1)&nbsp;override all _vfunc() members. 2)&nbsp;set the GIOChannel flags in your constructor.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This feature of being able to implement a custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">Glib::IOChannel</a> is deprecated in glibmm&nbsp;2.2. The vfunc interface has not yet stabilized enough to allow that -- the C++ wrapper went in by pure accident. Besides, it isn't terribly useful either. Thus please refrain from overriding any <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> vfuncs. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0a6c1cddcf00c77c6ab99b096c86544f"></a><!-- doxytag: member="Glib::IOChannel::~IOChannel" ref="0a6c1cddcf00c77c6ab99b096c86544f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Glib::IOChannel::~IOChannel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ded3d9a998914bcac0b3f1aef1eeb974"></a><!-- doxytag: member="Glib::IOChannel::IOChannel" ref="ded3d9a998914bcac0b3f1aef1eeb974" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::IOChannel::IOChannel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor that should be used by derived classes. 
<p>
Use this constructor if you want to inherit from <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a>. It will set up a GIOChannel that will call the vfuncs of your class even if it is being used from C code, and it will keep a reference to the C++ code while the GIOChannel exists. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c175ea1fd6ef84ac3758ca57b42b7f33"></a><!-- doxytag: member="Glib::IOChannel::create_from_file" ref="c175ea1fd6ef84ac3758ca57b42b7f33" args="(const std::string &amp;filename, const std::string &amp;mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_file           </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open a file <em>filename</em> as an I/O channel using mode <em>mode</em>. 
<p>
This channel will be closed when the last reference to it is dropped, so there is no need to call <a class="el" href="classGlib_1_1IOChannel.html#6affd4b4cbeeefe4965544f762922c35" title="Close the I/O channel.">close()</a> (though doing so will not cause problems, as long as no attempt is made to access the channel after it is closed). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of the file to open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>One of <code>"r"</code>, <code>"w"</code>, <code>"a"</code>, <code>"r+"</code>, <code>"w+"</code>, <code>"a+"</code>. These have the same meaning as in <code>fopen()</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> for the opened file. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors.">Glib::FileError</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="078698e18f61bb75fe3fd33d82970f5d"></a><!-- doxytag: member="Glib::IOChannel::create_from_fd" ref="078698e18f61bb75fe3fd33d82970f5d" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_fd           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an I/O channel from a file descriptor. 
<p>
On Unix, IOChannels created with this function work for any file descriptor or socket.<p>
On Win32, this can be used either for files opened with the MSVCRT (the Microsoft run-time C library) <code>_open()</code> or <code>_pipe()</code>, including file descriptors 0, 1 and 2 (corresponding to <code>stdin</code>, <code>stdout</code> and <code>stderr</code>), or for Winsock <code>SOCKET</code>s. If the parameter is a legal file descriptor, it is assumed to be such, otherwise it should be a <code>SOCKET</code>. This relies on <code>SOCKET</code>s and file descriptors not overlapping. If you want to be certain, call either <a class="el" href="classGlib_1_1IOChannel.html#1a22bd01752d233c23babdef800c0d87" title="Create an I/O channel for C runtime (emulated Unix-like) file descriptors.">create_from_win32_fd()</a> or <a class="el" href="classGlib_1_1IOChannel.html#087946554b86d42f1cd72277fd1b0530" title="Create an I/O channel for a winsock socket.">create_from_win32_socket()</a> instead as appropriate.<p>
The term file descriptor as used in the context of Win32 refers to the emulated Unix-like file descriptors MSVCRT provides. The native corresponding concept is file <code>HANDLE</code>. There isn't as of yet a way to get IOChannels for Win32 file <code>HANDLE</code>s. 
</div>
</div><p>
<a class="anchor" name="1a22bd01752d233c23babdef800c0d87"></a><!-- doxytag: member="Glib::IOChannel::create_from_win32_fd" ref="1a22bd01752d233c23babdef800c0d87" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_win32_fd           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an I/O channel for C runtime (emulated Unix-like) file descriptors. 
<p>
After calling add_watch() on a I/O channel returned by this function, you shouldn't call <a class="el" href="classGlib_1_1IOChannel.html#e5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character.">read()</a> on the file descriptor. This is because adding polling for a file descriptor is implemented on Win32 by starting a thread that sits blocked in a <code>read()</code> from the file descriptor most of the time. All reads from the file descriptor should be done by this internal GLib thread. Your code should call only <a class="el" href="classGlib_1_1IOChannel.html#e5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character.">IOChannel::read()</a>. 
</div>
</div><p>
<a class="anchor" name="087946554b86d42f1cd72277fd1b0530"></a><!-- doxytag: member="Glib::IOChannel::create_from_win32_socket" ref="087946554b86d42f1cd72277fd1b0530" args="(int socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_win32_socket           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>socket</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an I/O channel for a winsock socket. 
<p>
The parameter should be a <code>SOCKET</code>. Contrary to I/O channels for file descriptors (on Win32), you can use normal <code>recv()</code> or <code>recvfrom()</code> on sockets even if GLib is polling them. 
</div>
</div><p>
<a class="anchor" name="e5878a4510f52f194f18c0743f6a9b5c"></a><!-- doxytag: member="Glib::IOChannel::read" ref="e5878a4510f52f194f18c0743f6a9b5c" args="(gunichar &amp;thechar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read           </td>
          <td>(</td>
          <td class="paramtype">gunichar &amp;&nbsp;</td>
          <td class="paramname"> <em>thechar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a single UCS-4 character. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thechar</em>&nbsp;</td><td>The <a class="el" href="namespaceGlib_1_1Unicode.html">Unicode</a> character. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td>Reads a <a class="el" href="namespaceGlib_1_1Unicode.html">Unicode</a> character from <em>channel</em>. This function cannot be called on a channel with <code>0</code> encoding. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thechar</em>&nbsp;</td><td>A location to return a character. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A IOStatus. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1afb78d2e29a2f01a7034279a0c12636"></a><!-- doxytag: member="Glib::IOChannel::read" ref="1afb78d2e29a2f01a7034279a0c12636" args="(char *buf, gsize count, gsize &amp;bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a character sequence into memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A buffer to read data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The size of the buffer in bytes. Note that the buffer may not be complelely filled even if there is data in the buffer if the remaining data is not a complete character. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>The number of bytes read. This may be zero even on success if <em>count</em> &lt; 6 and the channel's encoding is not <code>""</code>. This indicates that the next UTF-8 character is too wide for the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td>Replacement for g_io_channel_read() with the new API. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A buffer to read data into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The size of the buffer. Note that the buffer may not be complelely filled even if there is data in the buffer if the remaining data is not a complete character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_read</em>&nbsp;</td><td>The number of bytes read. This may be zero even on success if count &lt; 6 and the channel's encoding is non-<code>0</code>. This indicates that the next UTF-8 character is too wide for the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4553088deea02ebea2ab7a9e2cff0a1c"></a><!-- doxytag: member="Glib::IOChannel::read" ref="4553088deea02ebea2ab7a9e2cff0a1c" args="(Glib::ustring &amp;str, gsize count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a maximum of <em>count</em> bytes into <em>str</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of bytes to read. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The characters that have been read. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2950510fff168d5753ee1eb14714d67a"></a><!-- doxytag: member="Glib::IOChannel::read_line" ref="2950510fff168d5753ee1eb14714d67a" args="(Glib::ustring &amp;line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read_line           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>line</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a whole line. 
<p>
Reads until the line separator is found, which is included in the result string. <dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>line</em>&nbsp;</td><td>The line that was read. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d64e84ab360b3c83399c94076487df1"></a><!-- doxytag: member="Glib::IOChannel::read_to_end" ref="0d64e84ab360b3c83399c94076487df1" args="(Glib::ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read_to_end           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads all the remaining data from the file. 
<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The resulting string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5ef249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a> on success. This function never returns <a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5ed42ae91b402716ab4faaec9b0f3823fe">Glib::IO_STATUS_EOF</a>. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cacb5599be21f549911c6aca5f820fcf"></a><!-- doxytag: member="Glib::IOChannel::write" ref="cacb5599be21f549911c6aca5f820fcf" args="(const Glib::ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a string to the I/O channel. 
<p>
Note that this method does not return the number of characters written. If the channel is blocking and the returned value is <a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5ef249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a>, the whole string was written. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>the string to write. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="29114ed2bcb64b8af551271394968528"></a><!-- doxytag: member="Glib::IOChannel::write" ref="29114ed2bcb64b8af551271394968528" args="(const char *buf, gssize count, gsize &amp;bytes_written)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&nbsp;</td>
          <td class="paramname"> <em>bytes_written</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a memory area of <em>count</em> bytes to the I/O channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>The start of the memory area. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes to write. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bytes_written</em>&nbsp;</td><td>The number of bytes written to the channel. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td>Replacement for g_io_channel_write() with the new API.</td></tr>
  </table>
</dl>
On seekable channels with encodings other than <code>0</code> or UTF-8, generic mixing of reading and writing is not allowed. A call to g_io_channel_write_chars() may only be made on a channel from which data has been read in the cases described in the documentation for g_io_channel_set_encoding(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>A buffer to write data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The size of the buffer. If -1, the buffer is taken to be a nul-terminated string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytes_written</em>&nbsp;</td><td>The number of bytes written. This can be nonzero even if the return value is not IO_STATUS_NORMAL. If the return value is IO_STATUS_NORMAL and the channel is blocking, this will always be equal to <em>count</em> if <em>count</em> &gt;= 0. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e0a187ff012b3b90c6d3d8593c18e92"></a><!-- doxytag: member="Glib::IOChannel::write" ref="5e0a187ff012b3b90c6d3d8593c18e92" args="(gunichar unichar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write           </td>
          <td>(</td>
          <td class="paramtype">gunichar&nbsp;</td>
          <td class="paramname"> <em>unichar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a single UCS-4 character to the I/O channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unichar</em>&nbsp;</td><td>The character to write. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td>Writes a <a class="el" href="namespaceGlib_1_1Unicode.html">Unicode</a> character to <em>channel</em>. This function cannot be called on a channel with <code>0</code> encoding. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thechar</em>&nbsp;</td><td>A character. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A IOStatus. </dd></dl>

</div>
</div><p>
<a class="anchor" name="65a5048c32ecde11827b5ae1973ee0b1"></a><!-- doxytag: member="Glib::IOChannel::seek" ref="65a5048c32ecde11827b5ae1973ee0b1" args="(gint64 offset, SeekType type=SEEK_TYPE_SET)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::seek           </td>
          <td>(</td>
          <td class="paramtype">gint64&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga3767731311bdba4ef42dc99215e5cda">SeekType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>SEEK_TYPE_SET</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seek the I/O channel to a specific position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset in bytes from the position specified by <em>type</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>A SeekType. The type <a class="el" href="group__glibmmEnums.html#gga3767731311bdba4ef42dc99215e5cda48f0a394042c3a8e117b2ae64af33960">Glib::SEEK_TYPE_CUR</a> is only allowed in those cases where a call to <a class="el" href="classGlib_1_1IOChannel.html#b1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel.">set_encoding()</a> is allowed. See the documentation for <a class="el" href="classGlib_1_1IOChannel.html#b1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel.">set_encoding()</a> for details. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td>Replacement for g_io_channel_seek() with the new API. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The offset in bytes from the position specified by <em>type</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>A SeekType. The type SEEK_CUR is only allowed in those cases where a call to g_io_channel_set_encoding() is allowed. See the documentation for g_io_channel_set_encoding() for details. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba6702093bd1c58ea22231446ed2f6e4"></a><!-- doxytag: member="Glib::IOChannel::flush" ref="ba6702093bd1c58ea22231446ed2f6e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::flush           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush the buffers of the I/O channel. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors.">Glib::ConvertError</a></em>&nbsp;</td><td>Flushes the write buffer for the GIOChannel. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation: One of IO_CHANNEL_NORMAL, IO_CHANNEL_AGAIN, or IO_CHANNEL_ERROR. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6affd4b4cbeeefe4965544f762922c35"></a><!-- doxytag: member="Glib::IOChannel::close" ref="6affd4b4cbeeefe4965544f762922c35" args="(bool flush=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::close           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flush</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the I/O channel. 
<p>
Any pending data to be written will be flushed if <em>flush</em> is <code>true</code>. The channel will not be freed until the last reference is dropped. Accessing the channel after closing it is considered an error. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flush</em>&nbsp;</td><td>Whether to <a class="el" href="classGlib_1_1IOChannel.html#ba6702093bd1c58ea22231446ed2f6e4" title="Flush the buffers of the I/O channel.">flush()</a> pending data before closing the channel. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td>Close an IO channel. Any pending data to be written will be flushed if <em>flush</em> is <code>true</code>. The channel will not be freed until the last reference is dropped using g_io_channel_unref(). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flush</em>&nbsp;</td><td>If <code>true</code>, flush pending. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Location to store a <a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">IOChannelError</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f5c5979ad729df9524fcb1940e5d2fe"></a><!-- doxytag: member="Glib::IOChannel::get_buffer_size" ref="2f5c5979ad729df9524fcb1940e5d2fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize Glib::IOChannel::get_buffer_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> internal buffer size. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The buffer size. Gets the buffer size. <p>
The size of the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="535767c92f2678e5e72051f6f4bc5326"></a><!-- doxytag: member="Glib::IOChannel::set_buffer_size" ref="535767c92f2678e5e72051f6f4bc5326" args="(gsize size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_buffer_size           </td>
          <td>(</td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the internal <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> buffer size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The buffer size the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> should use. Sets the buffer size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the buffer, or 0 to let GLib pick a good size. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c15e424b863d398ed458315b7f799243"></a><!-- doxytag: member="Glib::IOChannel::get_flags" ref="c15e424b863d398ed458315b7f799243" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> Glib::IOChannel::get_flags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current flags for a <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a>, including read-only flags such as <a class="el" href="group__glibmmEnums.html#ggee093e5db5bc1ea5738771ba0d1af3b7162bfe5ccb18465d0f11e954cc4a89d9">Glib::IO_FLAG_IS_READABLE</a>. 
<p>
The values of the flags <a class="el" href="group__glibmmEnums.html#ggee093e5db5bc1ea5738771ba0d1af3b7162bfe5ccb18465d0f11e954cc4a89d9">Glib::IO_FLAG_IS_READABLE</a> and <a class="el" href="group__glibmmEnums.html#ggee093e5db5bc1ea5738771ba0d1af3b7f9738e0234ae1d1f15c4512d6edb16db">Glib::IO_FLAG_IS_WRITEABLE</a> are cached for internal use by the channel when it is created. If they should change at some later point (e.g. partial shutdown of a socket with the UNIX <code>shutdown()</code> function), the user should immediately call <a class="el" href="classGlib_1_1IOChannel.html#c15e424b863d398ed458315b7f799243" title="Get the current flags for a IOChannel, including read-only flags such as Glib::IO_FLAG_IS_READABLE...">get_flags()</a> to update the internal values of these flags. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Bitwise combination of the flags set on the channel. Gets the current flags for a <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a>, including read-only flags such as IO_FLAG_IS_READABLE.</dd></dl>
The values of the flags IO_FLAG_IS_READABLE and IO_FLAG_IS_WRITEABLE are cached for internal use by the channel when it is created. If they should change at some later point (e.g. partial shutdown of a socket with the UNIX shutdown() function), the user should immediately call g_io_channel_get_flags() to update the internal values of these flags. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The flags which are set on the channel. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6c16c87c174d836247f47c2b87539fd"></a><!-- doxytag: member="Glib::IOChannel::set_flags" ref="b6c16c87c174d836247f47c2b87539fd" args="(IOFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::set_flags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set flags on the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Bitwise combination of the flags to set. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The operation result code. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td>Sets the (writeable) flags in <em>channel</em> to ( <em>flags</em>&amp; IO_CHANNEL_SET_MASK). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>The flags to set on the IO channel. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The status of the operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="baf37b0d76cd41628fd0c41a674495de"></a><!-- doxytag: member="Glib::IOChannel::set_buffered" ref="baf37b0d76cd41628fd0c41a674495de" args="(bool buffered)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_buffered           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>buffered</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the buffering status of the I/O channel. 
<p>
The buffering state can only be set if the channel's encoding is <code>""</code>. For any other encoding, the channel must be buffered.<p>
A buffered channel can only be set unbuffered if the channel's internal buffers have been flushed. Newly created channels or channels which have returned <a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5ed42ae91b402716ab4faaec9b0f3823fe">Glib::IO_STATUS_EOF</a> not require such a flush. For write-only channels, a call to <a class="el" href="classGlib_1_1IOChannel.html#ba6702093bd1c58ea22231446ed2f6e4" title="Flush the buffers of the I/O channel.">flush()</a> is sufficient. For all other channels, the buffers may be flushed by a call to <a class="el" href="classGlib_1_1IOChannel.html#65a5048c32ecde11827b5ae1973ee0b1" title="Seek the I/O channel to a specific position.">seek()</a>. This includes the possibility of seeking with seek type <a class="el" href="group__glibmmEnums.html#gga3767731311bdba4ef42dc99215e5cda48f0a394042c3a8e117b2ae64af33960">Glib::SEEK_TYPE_CUR</a> and an offset of zero. Note that this means that socket-based channels cannot be set unbuffered once they have had data read from them.<p>
The default state of the channel is buffered.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffered</em>&nbsp;</td><td>Whether to set the channel buffered or unbuffered. The buffering state can only be set if the channel's encoding is <code>0</code>. For any other encoding, the channel must be buffered.</td></tr>
  </table>
</dl>
A buffered channel can only be set unbuffered if the channel's internal buffers have been flushed. Newly created channels or channels which have returned IO_STATUS_EOF not require such a flush. For write-only channels, a call to g_io_channel_flush() is sufficient. For all other channels, the buffers may be flushed by a call to g_io_channel_seek_position(). This includes the possibility of seeking with seek type SEEK_CUR and an offset of zero. Note that this means that socket-based channels cannot be set unbuffered once they have had data read from them.<p>
On unbuffered channels, it is safe to mix read and write calls from the new and old APIs, if this is necessary for maintaining old code.<p>
The default state of the channel is buffered. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffered</em>&nbsp;</td><td>Whether to set the channel buffered or unbuffered. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3013c245f30ca81e11c01f8a031b1745"></a><!-- doxytag: member="Glib::IOChannel::get_buffered" ref="3013c245f30ca81e11c01f8a031b1745" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::IOChannel::get_buffered           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the buffering status of the I/O channel. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The buffering status of the channel. Return <a class="el" href="classGlib_1_1Value.html" title="Generic value implementation for custom types.">Value</a>: <code>true</code> if the <em>channel</em> is buffered. <p>
<code>true</code> if the <em>channel</em> is buffered. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ba943e998468e3b86d841c5aec8a551"></a><!-- doxytag: member="Glib::IOChannel::get_buffer_condition" ref="9ba943e998468e3b86d841c5aec8a551" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MainLoop.html#gbd96381793b70d4ae32c725926990918">IOCondition</a> Glib::IOChannel::get_buffer_condition           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the I/O channel. 
<p>
Only the flags <a class="el" href="group__MainLoop.html#ggbd96381793b70d4ae32c725926990918f244f3e8c1c9525762f3630befd76336">Glib::IO_IN</a> and <a class="el" href="group__MainLoop.html#ggbd96381793b70d4ae32c72592699091860f61c8f26f2bb61afd3ad8afd673099">Glib::IO_OUT</a> may be set. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Bitwise combination of <a class="el" href="group__MainLoop.html#gbd96381793b70d4ae32c725926990918" title="A bitwise combination representing an I/O condition to watch for on an event source...">Glib::IOCondition</a> flags. This function returns a IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a>. Only the flags IO_IN and IO_OUT may be set. <p>
A IOCondition. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c93b128c8ee396702b2a20c5a060949d"></a><!-- doxytag: member="Glib::IOChannel::get_close_on_unref" ref="c93b128c8ee396702b2a20c5a060949d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::IOChannel::get_close_on_unref           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether the file/socket/whatever associated with the I/O channel will be closed when the channel receives its final unref and is destroyed. 
<p>
The default value of this is <code>true</code> for channels created by <a class="el" href="classGlib_1_1IOChannel.html#c175ea1fd6ef84ac3758ca57b42b7f33" title="Open a file filename as an I/O channel using mode mode.">create_from_file()</a>, and <code>false</code> for all other channels. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether the channel will be closed on the final unref of the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> object. Return value: Whether the channel will be closed on the final unref of <p>
Whether the channel will be closed on the final unref of the GIOChannel data structure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f4fbc2a4c3670863fbf504d7fc96253"></a><!-- doxytag: member="Glib::IOChannel::set_close_on_unref" ref="3f4fbc2a4c3670863fbf504d7fc96253" args="(bool do_close)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_close_on_unref           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>do_close</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setting this flag to <code>true</code> for a channel you have already closed can cause problems. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>do_close</em>&nbsp;</td><td>Whether to close the channel on the final unref of the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and...">IOChannel</a> object. The default value of this is <code>true</code> for channels created by <a class="el" href="classGlib_1_1IOChannel.html#c175ea1fd6ef84ac3758ca57b42b7f33" title="Open a file filename as an I/O channel using mode mode.">create_from_file()</a>, and <code>false</code> for all other channels. Setting this flag to <code>true</code> for a channel you have already closed can cause problems. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>do_close</em>&nbsp;</td><td>Whether to close the channel on the final unref of the GIOChannel data structure. The default value of this is <code>true</code> for channels created by g_io_channel_new_file(), and <code>false</code> for all other channels. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b1d3ae667bd425ef830929a67cf526e0"></a><!-- doxytag: member="Glib::IOChannel::set_encoding" ref="b1d3ae667bd425ef830929a67cf526e0" args="(const std::string &amp;encoding=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::set_encoding           </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code><a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the encoding for the input/output of the channel. 
<p>
The internal encoding is always UTF-8. The default encoding for the external file is UTF-8. The encoding <code>""</code> is safe to use with binary data.<p>
The encoding can only be set if one of the following conditions is true:<p>
<ol type=1>
<li>The channel was just created, and has not been written to or read from yet.</li><li>The channel is write-only.</li><li>The channel is a file, and the file pointer was just repositioned by a call to seek_position(). (This flushes all the internal buffers.)</li><li>The current encoding is <code>""</code> or UTF-8.</li><li>One of the read methods has just returned <a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5ed42ae91b402716ab4faaec9b0f3823fe">Glib::IO_STATUS_EOF</a> (or, in the case of <a class="el" href="classGlib_1_1IOChannel.html#0d64e84ab360b3c83399c94076487df1" title="Reads all the remaining data from the file.">read_to_end()</a>, <a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5ef249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a>).</li><li>The <a class="el" href="classGlib_1_1IOChannel.html#e5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character.">read()</a> method has returned <a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5e5a33609d7ff07e1d711185c0765cf5de">Glib::IO_STATUS_AGAIN</a> or thrown a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> exception. This may be useful in the case of <a class="el" href="classGlib_1_1ConvertError.html#ea4b79ac3149c1fcfcab32155e3561a9335a4cb227118026dd0c25661f294d10">ConvertError::ILLEGAL_SEQUENCE</a>. Returning one of these statuses from <a class="el" href="classGlib_1_1IOChannel.html#2950510fff168d5753ee1eb14714d67a" title="Read a whole line.">read_line()</a> or <a class="el" href="classGlib_1_1IOChannel.html#0d64e84ab360b3c83399c94076487df1" title="Reads all the remaining data from the file.">read_to_end()</a> does <em>not</em> guarantee that the encoding can be changed.</li></ol>
<p>
Channels which do not meet one of the above conditions cannot call seek_position() with a seek type of <a class="el" href="group__glibmmEnums.html#gga3767731311bdba4ef42dc99215e5cda48f0a394042c3a8e117b2ae64af33960">Glib::SEEK_TYPE_CUR</a> and, if they are "seekable", cannot call <a class="el" href="classGlib_1_1IOChannel.html#cacb5599be21f549911c6aca5f820fcf" title="Write a string to the I/O channel.">write()</a> after calling one of the API "read" methods.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding name, or <code>""</code> for binary. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="group__glibmmEnums.html#gg23fb251e48485b62a9c2677bb1f87d5ef249c5b8e984c37db0847258aeeae86a">Glib::IO_STATUS_NORMAL</a> if the encoding was successfully set. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors.">Glib::IOChannelError</a></em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e52a79ec5f3acc2b0990870668c4ea2a"></a><!-- doxytag: member="Glib::IOChannel::get_encoding" ref="e52a79ec5f3acc2b0990870668c4ea2a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a> Glib::IOChannel::get_encoding           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the encoding of the I/O channel. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current encoding of the channel. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d42d03bdd0288cf5517737a73f7268b3"></a><!-- doxytag: member="Glib::IOChannel::set_line_term" ref="d42d03bdd0288cf5517737a73f7268b3" args="(const std::string &amp;term=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_line_term           </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>term</em> = <code><a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a>()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fd08e7a2a6cbfbdad2ef599c9eadcc01"></a><!-- doxytag: member="Glib::IOChannel::get_line_term" ref="fd08e7a2a6cbfbdad2ef599c9eadcc01" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/namespacestd.html#a48">std::string</a> Glib::IOChannel::get_line_term           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="755c88fe8c78dc0727b5686fc62b736c"></a><!-- doxytag: member="Glib::IOChannel::create_watch" ref="755c88fe8c78dc0727b5686fc62b736c" args="(IOCondition condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOSource.html">IOSource</a>&gt; Glib::IOChannel::create_watch           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MainLoop.html#gbd96381793b70d4ae32c725926990918">IOCondition</a>&nbsp;</td>
          <td class="paramname"> <em>condition</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object. 
<p>
Create a slot from a function to be called when condition is met for the channel with <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/group__s20__3__7__adaptors.html#ga1">sigc::ptr_fun()</a> or <a class="elRef" doxygen="libstdc++.tag.xml:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/group__s20__3__8__memadaptors.html#ga2">sigc::mem_fun()</a> and pass it into the connect() function of the returned <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object. Polling of the channel will start when you attach a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">MainContext</a> object to the returned <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object using its attach() function.<p>
<a class="el" href="group__MainLoop.html#gf391654b755a32169d18be4835677376" title="Convenience I/O signal.">Glib::signal_io()</a>.connect() is a simpler interface to the same functionality, for the case where you want to add the source to the default main context. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>condition</em>&nbsp;</td><td>The condition to watch for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object that can be polled from a MainContext's event loop. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a63e3a39347848387cd9422d0073a7be"></a><!-- doxytag: member="Glib::IOChannel::reference" ref="a63e3a39347848387cd9422d0073a7be" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Glib::IOChannel::reference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4c57bf6b00844fc3ddb9d0e60cac7dcf"></a><!-- doxytag: member="Glib::IOChannel::unreference" ref="4c57bf6b00844fc3ddb9d0e60cac7dcf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Glib::IOChannel::unreference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b05ed8535a51b04749e11386c845a581"></a><!-- doxytag: member="Glib::IOChannel::gobj" ref="b05ed8535a51b04749e11386c845a581" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GIOChannel* Glib::IOChannel::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="iochannel_8h-source.html#l00717">gobject_</a>.</p>

</div>
</div><p>
<a class="anchor" name="ad550f12d9d2ec2fef0a2c7ba78f2595"></a><!-- doxytag: member="Glib::IOChannel::gobj" ref="ad550f12d9d2ec2fef0a2c7ba78f2595" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GIOChannel* Glib::IOChannel::gobj           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="iochannel_8h-source.html#l00717">gobject_</a>.</p>

</div>
</div><p>
<a class="anchor" name="bfb4faa07e80b86f21b0f18f0b8606cd"></a><!-- doxytag: member="Glib::IOChannel::read_vfunc" ref="bfb4faa07e80b86f21b0f18f0b8606cd" args="(char *buf, gsize count, gsize &amp;bytes_read)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read_vfunc           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&nbsp;</td>
          <td class="paramname"> <em>bytes_read</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#ad85c2e9149428db83575ff98bdac482">Glib::StreamIOChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="4ed5372da9d4ad3465012fc2317507b5"></a><!-- doxytag: member="Glib::IOChannel::write_vfunc" ref="4ed5372da9d4ad3465012fc2317507b5" args="(const char *buf, gsize count, gsize &amp;bytes_written)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write_vfunc           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&nbsp;</td>
          <td class="paramname"> <em>bytes_written</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#9b6ce8cea1b948c1d408c946c4ad27eb">Glib::StreamIOChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="781de88aec2c032d05f74402779665f3"></a><!-- doxytag: member="Glib::IOChannel::seek_vfunc" ref="781de88aec2c032d05f74402779665f3" args="(gint64 offset, SeekType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::seek_vfunc           </td>
          <td>(</td>
          <td class="paramtype">gint64&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga3767731311bdba4ef42dc99215e5cda">SeekType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#82c4a6b077c542d1b79c23ecc6b1772f">Glib::StreamIOChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="735b70808acbb542b04bf55b0133927e"></a><!-- doxytag: member="Glib::IOChannel::close_vfunc" ref="735b70808acbb542b04bf55b0133927e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::close_vfunc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#20deabe6a3bc6b1488975375e61af626">Glib::StreamIOChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="f8f690f1e0a8945b75ad7be4949e44cf"></a><!-- doxytag: member="Glib::IOChannel::set_flags_vfunc" ref="f8f690f1e0a8945b75ad7be4949e44cf" args="(IOFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#g23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::set_flags_vfunc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#dd1a29876a6d3b553f41ef21dd654f67">Glib::StreamIOChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="e3326db3877358b563de11fb3dd8367f"></a><!-- doxytag: member="Glib::IOChannel::get_flags_vfunc" ref="e3326db3877358b563de11fb3dd8367f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#gee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> Glib::IOChannel::get_flags_vfunc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#29a782e3ab6d7fc1b77f612c97c195f6">Glib::StreamIOChannel</a>.</p>

</div>
</div><p>
<a class="anchor" name="128f2bfd977617a6a1a7e4a7fbe6aa5b"></a><!-- doxytag: member="Glib::IOChannel::create_watch_vfunc" ref="128f2bfd977617a6a1a7e4a7fbe6aa5b" args="(IOCondition cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Source.html">Glib::Source</a>&gt; Glib::IOChannel::create_watch_vfunc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MainLoop.html#gbd96381793b70d4ae32c725926990918">IOCondition</a>&nbsp;</td>
          <td class="paramname"> <em>cond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#77595f06e524cd2cb3dc7958fd274f4f">Glib::StreamIOChannel</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="6683e47c0d78492b83d7021288d9b6d0"></a><!-- doxytag: member="Glib::IOChannel::gobject_" ref="6683e47c0d78492b83d7021288d9b6d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GIOChannel* <a class="el" href="classGlib_1_1IOChannel.html#6683e47c0d78492b83d7021288d9b6d0">Glib::IOChannel::gobject_</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Referenced by <a class="el" href="iochannel_8h-source.html#l00713">gobj()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="iochannel_8h.html">iochannel.h</a></ul>
</div>
</div> <!-- end main content -->

<hr><address><small>
Generated for glibmm 2.4 by <a href="http://www.doxygen.org/index.html">
Doxygen</a> 1.5.6 &copy;&nbsp;1997-2001</small></address>
</body>
</html>
